#!/bin/bash --norc
# New mkdumprd
#
# Copyright 2011 Red Hat, Inc.
#
# Written by Cong Wang <amwang@redhat.com>
#

export IN_KDUMP=1

conf_file="/etc/kdump.conf"
SSH_KEY_LOCATION="/root/.ssh/kdump_id_rsa"
SAVE_PATH=$(grep ^path $conf_file| cut -d' '  -f2)
[ -z "$SAVE_PATH" ] && SAVE_PATH="/var/crash"
extra_modules=""
dracut_args=("--hostonly" "-o" "plymouth dash")

perror_exit() {
    echo $@ >&2
    exit 1
}

perror() {
    echo $@ >&2
}

get_persistent_dev() {
    local i _tmp _dev

    _dev=$(udevadm info --query=name --name="$1" 2>/dev/null)
    [ -z "$_dev" ] && {
        perror_exit "Kernel dev name of $1 is not found."
    }

    for i in /dev/mapper/* /dev/disk/by-uuid/* /dev/disk/by-id/*; do
        _tmp=$(udevadm info --query=name --name="$i" 2>/dev/null)
        if [ "$_tmp" = "$_dev" ]; then
            echo $i
            return
        fi
    done

    perror_exit "Persistent device name of $1 is not found."
}

add_dracut_arg() {
    while [ $# -gt 0 ];
    do
        dracut_args+=("$1")
        shift
    done
}

add_dracut_module() {
    add_dracut_arg "--add" "$1"
}

add_dracut_mount() {
    add_dracut_arg "--mount" "$1"
}

add_dracut_sshkey() {
    add_dracut_arg "--sshkey" "$1"
}

# Generic substring function.  If $2 is in $1, return 0.
strstr() { [[ $1 =~ $2 ]]; }

target_is_root() {
    local _t
    _t=$(findmnt -k -n -r -o TARGET $1|sort|head -1)
    [ "$_t" = "/" ]
}

# caller should ensure $1 is valid and mounted in 1st kernel
to_mount() {
    local _dev=$1 _s _t _o _mntopts _pdev

    _s=$(findmnt -k -f -n -r -o SOURCE $_dev)
    _t=$(findmnt -k -f -n -r -o TARGET,FSTYPE $_dev)
    _o=$(findmnt -k -f -n -r -o OPTIONS $_dev)
    _o=${_o/#ro/rw} #mount fs target as rw in 2nd kernel
    _mntopts="$_t $_o"
    #for non-nfs _dev converting to use udev persistent name
    if [ -b "$_s" ]; then
        _pdev="$(get_persistent_dev $_s)"
    else
        _pdev=$_dev
    fi

    echo "$_pdev $_mntopts"
}

to_mount_point() {
    echo $(findmnt -k -f -n -r -o TARGET $1)
}

is_readonly_mount() {
    local _mnt
    _mnt=$(findmnt -k -f -n -r -o OPTIONS $1)

    #fs/proc_namespace.c: show_mountinfo():
    #seq_puts(m, mnt->mnt_flags & MNT_READONLY ? " ro" : " rw");
    [[ "$_mnt" =~ ^ro ]]
}

#Function: get_ssh_size
#$1=dump target
get_ssh_size() {
    local _opt _out _size
    _opt="-i $SSH_KEY_LOCATION -o BatchMode=yes -o StrictHostKeyChecking=yes"
    _out=$(ssh -q -n $_opt $1 "df -P $SAVE_PATH")
    [ $? -ne 0 ] && {
        perror_exit "checking remote ssh server available size failed."
    }
    #ssh output removed the line break, so print $11 instead of $4
    _size=$(echo -n $_out|tail -1 | awk '{print $11}')
    echo -n $_size
}

#mkdir if save path does not exist on dump target filesystem
#$1=dump target
#caller should ensure $1 is mounted
mkdir_save_path() {
    local _mnt=$(to_mount_point $1)
    local _remount="no"
    local _ret

    [ ! -d ${_mnt}/$SAVE_PATH ] && {
        if is_readonly_mount $1; then
            echo "Mounting $1 as read-write for creating dump directory.."
            mount -o remount,rw $1 || {
                perror_exit "Mounting $1 as read-write failed."
            }
            _remount="yes"
        fi
        mkdir -p ${_mnt}/$SAVE_PATH
        _ret=$?
        [ "$_remount" = "yes" ] && {
            echo "Remounting $1 as read-only."
            mount -o remount,ro $1 || {
                perror_exit "Remounting $1 as read-only failed."
            }
        }
        [ $_ret -ne 0 ] && {
            perror_exit "Creating ${_mnt}/$SAVE_PATH failed."
        }
    }
}

#Function: get_fs_size
#$1=dump target
get_fs_size() {
    local _mnt=$(to_mount_point $1)
    echo -n $(df -P "${_mnt}/$SAVE_PATH"|tail -1|awk '{print $4}')
}

#Function: get_raw_size
#$1=dump target
get_raw_size() {
        echo -n $(fdisk -s "$1")
}

#Function: check_size
#$1: dump type string ('raw', 'fs', 'ssh')
#$2: dump target
check_size() {
    local avail memtotal

    memtotal=$(awk '/MemTotal/{print $2}' /proc/meminfo)
    case "$1" in
        raw)
            avail=$(get_raw_size "$2")
            ;;
        ssh)
            avail=$(get_ssh_size "$2")
            ;;
        fs)
            avail=$(get_fs_size "$2")
            ;;
        *)
            return
    esac

    if [ $avail -lt $memtotal ]; then
        echo "Warning: There might not be enough space to save a vmcore."
        echo "         The size of $2 should be greater than $memtotal kilo bytes."
    fi
}

is_ssh_dump_target()
{
    grep -q "^ssh.*@" $conf_file
}

is_raw_dump_target()
{
    grep -q "^raw" $conf_file
}

# $1: core_collector config value
verify_core_collector() {
    if grep -q "^raw" $conf_file && [ "${1%% *}" != "makedumpfile" ]; then
        echo "Warning: specifying a non-makedumpfile core collector, you will have to recover the vmcore manually."
    fi
    if is_ssh_dump_target || is_raw_dump_target; then
        if [ "${1%% *}" = "makedumpfile" ]; then
            ! strstr "$1" "-F" && {
                perror_exit "The specified dump target needs makedumpfile \"-F\" option."
            }
        fi
    fi
}

add_mount() {
    if ! target_is_root "$1"; then
        local _mnt=$(to_mount "$1")
        add_dracut_mount "$_mnt"
    fi
}

# firstly get right SSH_KEY_LOCATION
keyfile=$(awk '/^sshkey/ {print $2}' $conf_file)
if [ -f "$keyfile" ]; then
    # canonicalize the path
    SSH_KEY_LOCATION=$(/usr/bin/readlink -m $keyfile)
fi

if [ "$(uname -m)" = "s390x" ]; then
    add_dracut_module "znet"
fi

while read config_opt config_val;
do
    case "$config_opt" in
    extra_modules)
        extra_modules="$extra_modules $config_val"
        ;;
    ext[234]|xfs|btrfs|minix|nfs)
        if ! findmnt $config_val >/dev/null; then
            perror_exit "Dump target $config_val is probably not mounted."
        fi

        if [ "$config_opt" = "nfs" ]; then
            add_dracut_module "nfs"
        fi
        add_mount "$config_val"
        mkdir_save_path $config_val
        check_size fs $config_val
        ;;
    raw)
        #checking raw disk writable
        dd if=$config_val count=1 of=/dev/null > /dev/null 2>&1 || {
            perror_exit "Bad raw disk $config_val"
        }
        add_dracut_arg "--device" "$(get_persistent_dev $config_val)"
        check_size raw $config_val
        ;;
    ssh)
        if strstr "$config_val" "@";
        then
            check_size ssh $config_val
            add_dracut_module "ssh-client"
		add_dracut_sshkey "$SSH_KEY_LOCATION"
        else
            perror_exit "Bad ssh dump target $config_val"
        fi
        ;;
    core_collector)
        verify_core_collector "$config_val"
        ;;
    *)
        if [ -n $(echo $config_opt | grep "^#.*$") ]
        then
            continue
        fi
        ;;
    esac
done < $conf_file

if [ -n "$extra_modules" ]
then
    add_dracut_arg "--add-drivers" "$extra_modules"
fi

dracut "${dracut_args[@]}" -M "$@"
_rc=$?
sync
exit $_rc
